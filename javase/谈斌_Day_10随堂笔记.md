### Day_10随堂笔记

#### 多态

```java
多态: 事物的多种形态
    动物 : 狗,猫,老鼠,人
    水 :  液态水,固态冰,气态水蒸气    
        
多态的本质:	引用数据类型子父类之间的类型转换问题   
    基本数据类型:
    	自动提升: double d = 100;
		强制转换: int num = (int)d;
	引用数据类型:
		向上转型: 父类引用接受子类对象
			Animal a = new Dog(); -> 这里有只动物它是狗
            Dog d = new Animal(); -> 错误!     
        向下转型:
			Animal a = new Dog(); -> 这里有只动物它是狗
            Dog d = (Dog)a; -> 向下转型
               
```

#### 多态的前提条件

```java
1. 要有继承或者实现关系  --> 最为重要的前提条件
2. 有方法的重写 --> 是为了体现多态中特性: 动态绑定的方式执行方法
3. 父引用指向子类对象 --> Fu fu = new Zi();   -> 多态中的向上转型
```

#### 多态的成员访问问题

```java
多态的成员访问问题 参考 继承,实现关系下成员访问的特点
    
1. 成员变量 : 就近原则 -> 编译看左边,运行看左边
    
2. 成员方法 : 自己有(重写方法)调用自己的,自己没有找父类要,父类也没有报错
    
3. 构造方法 : 子类对象要加载优先加载父类    
```

#### 多态中方法访问动态绑定的问题

```java
以多态的方式创建对象,父引用调用方法,调用的是具体对象的方法;根据具体对象不同,调用的方法行为不同;
```

#### 多态弊端

```java
父引用不能访问子类的特有成员!!!
    
解决办法: 让父引用变回具体的对象类型
    子类型 子对象 = (子类型)(父引用);

    向下转型的快捷代码: .castvar
```

#### 多态的向上转型和向下转型

```java
向上转型:
	父类型 父引用 = new 子类型();

向下转型:
	子类型 子对象 = (子类型)(父引用);
```

#### 向下转型的问题

```java
ClassCastException : 类型转换异常
    
原因: 把对象转换成了错误的类型
    
解决办法:
	1. 把对象转换成正确的数据类型
    2. 提前预防
        方案1:
        格式:	对象引用 instanceof 类型
        功能: 判断前面的对象引用是否属于后面的类型,返回一个boolean类型的结果
        方案2:
			判断对象引用的字节码对象是否和类型的字节码对象一致
		.java文件(类) -编译-> .class文件(字节码文件) -运行-> 字节码文件以字节码对象的形式存在于方法区中
               //一个类只会有一个字节码文件
               //一个类的字节码对象也只有一个
               //类都有一个属性 : .class属性 -> 获取类的字节码对象  
               //字节码对象是 Class类型的对象 -> Class代表类的类
            格式: Class c1 = 父引用.getClass();
				 Class c2 = 类名.class;
					c1 == c2 --> 判断类的字节码对象和对象的字节码对象是否是同一个对象  
```

#### 多态运用的思想

```java
1. 以后创建对象能直接创建子类对象的,绝对不以多态的形式创建对象;

多态真实的使用场景: 
	1. 父引用作为方法的形式参数,启动方法传递实参的方式就有n+1种 (n代表有几个子类,1代表父类本身)
    2. 父引用作为方法的返回值类型,返回方法的结果类型就有n+1种(n代表有几个子类,1代表父类本身)
    3. 大类型的容器存储小类型的数据    
```

#### 权限修饰符

```java
public > protected > 不写 > private
    
public : 同一个模块都能访问
protected : 同一模块不同包只能继承关系下能访问
不写 : 在同一个包下可以访问
private : 同一个类中可以访问    
```

|               | 同一个类中 | 同一个包不同类中 | 不同包有继承关系 | 不同包无关类 |
| :-----------: | :--------: | :--------------: | :--------------: | :----------: |
|  **public**   |     √      |        √         |        √         |      √       |
| **protected** |     √      |        √         |        √         |              |
|   **不写**    |     √      |        √         |                  |              |
|  **private**  |     √      |                  |                  |              |

#### 代码块

```java
格式:
    {
        //代码块
    }
分类:
	局部代码块: 存在于方法内的代码块
        作用: 节约内存空间的
        //现在不用了!!     
    构造代码块:
		位置: 成员位置
        格式:	
            {
                //成员位置的一个大括号
            }
        执行时机: 每创建一次对象,构造代码块要执行一次,且优先于构造方法的执行
        作用: 为对象的出现做准备
        理解: 古时候的皇帝出行,前置出行的宫女太监都类似构造代码的功能    
    静态代码块:
		位置:  成员位置
        格式:
			static{
                //成员位置的一个被static修饰的大括号
            }
		执行时机: 类第一次加载的时候执行一次,且只执行一次
        作用: 为类的加载做准备
        理解: 驱动    
```

#### 匿名对象

```java
匿名 : 没有名字
对象 : 类名 对象名 = new 类名();    

匿名对象 : new 类名() -> 没有名字的对象!
    
使用场景: 当你只是用一次对象的时候,为了方便你可以使用匿名对象!
   	1. 作为方法的实际参数传递
    2. 作为方法的返回值进行返回

弊端: 匿名对象只能使用一次,如果再次使用是创建了新的对象;
	//如果一个对象要重复使用,不建议使用匿名对象!!    
```

#### 可变参数

```java
    可变参数:   一种形参的定义格式
        格式: 数据类型...变量名
        作用: 当形参列表上有此格式的形参,代表你可以传入任意个此类型的实际参数
        可变参数的本质 : 其实就是一个 此类型的数组
        注意事项:
            1. 可变参数的后面不可以有其他任意类型的形参
            2. 可变参数的前面可以有任意类型的形参
```

#### 内部类

```java
定义在类的内部的类叫内部类;
```

#### 成员内部类(了解)

```java
概念: 定义在类成员位置上的类叫成员内部类;

格式:
	public class Outer{//外部类
        //成员位置
        public class Inner{//成员内部类
            
        }
    }

在成员内部类内部访问元素:
        1. 访问和外部类同名的成员变量和成员方法都是优先访问内部类自己的
        2. 如何访问内外部类同名的元素??
            成员变量: Outer.this.成员变量
            成员方法: Outer.this.成员方法

    在第三方类中去访问内部类的成员:
        前提是: 创建内部类对象
        Outer.Inner inner = new Outer().new Inner();

    成员内部类: 当一个类所有的内容都是为另一个类服务的时候,你就可以把这个类定义成类的内部类;
```

#### 静态成员内部类(了解)

```java
静态成员内部类:
        格式:
            public class Outer{//外部类
                //成员位置
                public static class Inner{//静态成员内部类

                }
            }
        注意: 静态只能访问静态!!
            在静态内部类中访问外部类的成员时,外部类的成员必须是静态的!

        如何创建静态内部类的对象???
            Outer.Inner inner = new Outer.Inner();
```

#### 局部内部类(了解中的了解)

```java
定义在方法内的类叫局部内部类;

格式:
    class Outer{
        public void classMethod(){
            //创建一个内部类
            class Inner{

            }
            //创建内部类的对象
            Inner inner = new Inner();
        }
    }

    注意事项:
        1. 局部内部类中访问成员(内部类/外部类)和成员内部类访问成员的操作是一致!
        2. 如何在第三方类中创建局部内部类的对象 -> 做不了!
        3. 如何创建内部类对象呢 ? 此局部内部类只能在方法内使用!!
            使用时必须要在局部内部类的定义格式下方
            
         记住: 在方法的内部可以定义类!   
```

#### 匿名内部类(重点)

```java
匿名内部类是 继承父类、继承抽象父类、实现父接口的另一种简单的表达形式~
    
为什么学? 
   1, 匿名内部类的表现形式更为简单,更为方便!
   2, Lambda表达式的使用前提是 你会用匿名内部类!
    
匿名内部类的使用场景:
        当类的子类,抽象类的子类,接口的实现类只使用一次,为了方便我们可以不创建具体的类,而是用匿名内部类完成继承/实现的操作

    格式:
        new 接口名/父类/抽象父类(){
             //接口实现类,父类的子类,抽象父类的子类的类主体
        };

     匿名内部类匿掉的是 实现类/子类的 类名!!!

     匿名内部类的命名由JVM完成:
        以匿名内部类出现的类的名字加上编号
            例如: Demo$1.class

     匿名内部类在创建时顺便创建了这个不知名实现类/子类的对象!!

     匿名内部类的快速写法: 先写等号左边的父类型 父引用,再在等号右边勇敢的new接口 or new抽象父类    
```

