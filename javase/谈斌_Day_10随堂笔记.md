### Day_10随堂笔记

#### 权限修饰符(重点)

```java
权限修饰符 : 
	private < 不写 < protected < public
```

|               | 同一个类 | 同一个包不同类 | 不同包有继承/实现关系 | 不同包没有关系 |
| :-----------: | :------: | :------------: | :-------------------: | :------------: |
|  **private**  |    √     |       X        |           X           |       X        |
|   **不写**    |    √     |       √        |           X           |       X        |
| **protected** |    √     |       √        |           √           |       X        |
|  **public**   |    √     |       √        |           √           |       √        |

#### final关键字(重点)

```java
final : 最终的 -> 阉割手术
    
可以修饰的东西:
	final 可以修饰类
    final 可以修饰成员变量
    final 可以修饰成员方法
    final 可以修饰局部变量    
        
效果:
	final 可以修饰类 : 没有子类
    final 可以修饰成员变量 : 不可以修改,变自定义常量
        自定义常量 :  public static final 数据类型 常量名 = 初始化值;
    final 可以修饰成员方法 : 不可以重写
    final 可以修饰局部变量 : 不可以修改,变成局部的常量  
        
static public void main()    -> 也对 类、方法、变量之前的修饰符可以调换位置
```

#### 可变参数(重点)

```java
可变参数 : 关于形参格式的一种写法
    
    可变参数: 在定义方法形参的时候
        形参编写格式 :  数据类型...变量名
        实参 : 就可以传入任意个(0-n)此类型的实际参数

     可变参数的本质就是: 此类型的数组

     注意事项:
        1. 可变参数的后面不可以有任意类型的形参
        2. 可变参数的前面可以有任意类型的形参    
```

#### 匿名对象(重点)

```java
    匿名对象 : 没有名字的对象
       匿名 : 没有名字

   匿名对象可以做什么 :
        1. 可以调用对象的属性和行为

   匿名对象的弊端 : 对象是一次性的

   匿名对象的使用场景是什么? : 那么如果我只是用一次次对象,就可以为了方便使用匿名对象!
        1. 匿名对象作为实参
        2. 匿名对象作为方法的返回值

   总结 : 当我只使用一次,我就可以使用匿名系列的东西(匿名对象,匿名内部类),为了方便!!
     匿名都是一次性的,如果再次需要使用,新new的又是新的对象!! 所以如果一个东西需要重复使用就不要用匿名系列
```

#### 内部类

```java
内部类 : 定义在类里面的类叫内部类
```

#### 成员内部类(理解)

```java
成员 : 位置关系 -> 类中方法外
    
成员内部类 : 定义在类中方法外的类叫成员内部类
    
1. 成员属于对象!!!  
2. 当类出现在成员位置它也具备了成员的特点!!!
    
定义格式:
	public class Outer {//外部类
        //成员内部类
        public class Inner{//成员内部类

        }
    }

1. 在成员内部类内部访问 元素:
    System.out.println("numOut = " + numOut);
    System.out.println("numIn = " + numIn);
    int num = 333;
    System.out.println("num = " + num);//就近原则
    System.out.println("this.num = " + this.num);//内部类的num
    System.out.println("Outer.this.num = " + Outer.this.num);//外部类的num
    System.out.println("-------------------");
    methodIn();
    methodOut();
    this.method();//访问的本类的method
    Outer.this.method();//访问的外部类的method
```

#### 静态成员内部类(理解)

```java
格式:
public class Outer {
    static int numOut = 100;//晚
    int num = 111;
    public void methodOut(){
        System.out.println("methodOut");
    }
    public void method(){
        System.out.println("外部类的method");
    }

    //静态成员内部类
    public static class Inner{//早
        int numIn = 200;
        int num = 222;
        public void methodIn(){
            System.out.println("methodIn");
        }
        public void method(){
            System.out.println("内部类的method");
        }
    }
}

//在静态内部类中访问外部类的成员要求外部类的成员被static修饰;
//在第三方类中创建静态成员内部类的对象格式是:
	Outer.Inner inner = new Outer.Inner();
	//再用内部类的对象调用内部类的非静态成员;
```

#### 局部内部类(了解)

```java
局部 : 方法内
    
局部内部类是定义在方法内部的类;

格式:
	public class Outer {

        public void function(){
            //定义局部内部类
            class Inner{//局部位置是没有权限修饰符的

            }
            
            //只能在此地创建局部内部类对象并使用!!
        }

    }

    局部内部类只能在方法内部使用,在外部是用不了的!!
    局部内部类的使用还必须在其定义格式后!!
```

#### 匿名内部类(重点中的重点)

```java
匿名内部类 : 匿掉类名的内部类叫匿名内部类
    
注意:
	1. 匿名内部类匿掉的是类的名字!!
    2. 匿名内部类是一个局部内部类!!    
    3. 匿名内部类是关于 继承父类,继承抽象父类,实现父接口 的简写格式!!   
        
 格式:
	new 父类/抽象父类/接口(){
        //重写父类/抽象父类/接口的方法/抽象方法
    };  
	//这个整体是一个不知名的实现类和子类对象
	//如果要接收这个对象那么必须使用 父引用来接受 -> 多态
```

#### 代码块(理解)

```java
局部代码块 : 
	位置: 方法内
    格式: 
        {

        }
	作用: 限制局部变量的生命周期,节约内存的!! -> 现在不用了
        
构造代码块 : 
	位置 : 类中 方法外
    格式 : 
        {

        }
	作用: 为了对象的创建做准备
    执行规律 : 每创建一次对象执行一次且优先于构造方法执行
        
静态代码块 :
	位置 : 类中 方法外
    格式 :
		static{
            
        }
	作用: 类的驱动,为类的加载而做准备
    执行规律 : 类第一次加载的时候执行,且只执行一次!!    

执行顺序：
	父类静态变量初始化 -> 父类静态代码块 -> 子类静态变量初始化 -> 子类静态代码块 -> 父类成员变量初始化 -> 父类构造代码块 -> 父类构造方法 -> 子类成员变量初始化 -> 子类构造代码块 -> 子类构造方法
```





​	